## Overview
You’ll learn about alternatives to cookies using HTML 5 Web Storage and the standard Bearer authentication 
scheme for token-based authentication. You’ll enable cross-origin resource sharing (CORS) to allow 
cross-domain requests from the new site.
  
### Allowing cross-domain requests with CORS
If you need to communticate with existing API from different domain, the same-origin policy (SOP) throws up several 
problems for cookie-based authentication: 
- Attempting to send a login request from the new site is blocked because the JSON Content-Type header is disallowed by the SOP
- Even if you could send the request, the browser will ignore any Set-Cookie headers on a cross-origin response, so the session cookie will be discarded
- You also cannot read the anti-CSRF token, so cannot make requests from the new site even if the user is already logged in

Moving to an alternative token storage mechanism solves only the second issue, but if you want to allow 
cross-origin requests to your API from browser clients, you’ll need to solve the others. The solution is 
the CORS standard, introduced in 2013 to allow the SOP to be relaxed for some cross-origin requests
  
### CORS headers
You can learn more about CORS headers from Mozilla’s excellent article 
at https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS. The `Access-Control-Allow-Origin` and 
`Access-Control-Allow-Credentials` headers can be sent in the response to the preflight request and 
in the response to the actual request, whereas the other headers are sent only in response to 
the preflight request

> **_NOTE_** Because cookies are considered a credential by CORS, you need to return an 
> Access-Control-Allow-Credentials: true header from preflight requests; otherwise, the browser will not 
> send the session cookie. 
  
### Try it out
Start a server
```sh
mvn clean compile exec:java
```
Now start a second copy of the Natter UI by running the following command:
```sh
mvn clean compile exec:java -Dexec.args=9999
```

## Tokens without cookies
You’d like to mark your cookies as SameSite as a defense in depth against CSRF attacks, but SameSite 
cookies are incompatible with CORS. Apple’s Safari browser is also aggressively blocking cookies on some 
cross-site requests for privacy reasons, and some users are doing this manually through browser settings 
and extension

### Storing token state in a database
Although the SQL database storage used in this chapter is adequate for demonstration purposes and 
low-traffic APIs, a relational database may not be a perfect choice for all deployments. Authentication 
tokens are validated on every request, so the cost of a database transaction for every lookup can soon 
add up. On the other hand, tokens are usually extremely simple in structure, so they don’t need 
a complicated database schema or sophisticated integrity constraints. At the same time, token state 
rarely changes after a token has been issued, and a fresh token should be generated whenever any 
security-sensitive attributes change to avoid session fixation attacks. This means that many uses of 
tokens are also largely unaffected by consistency worries.

For these reasons, many production implementations of token storage opt for non-relational database 
backends, such as the Redis in-memory key-value store (https://redis.io), or a NoSQL JSON store that 
emphasizes speed and availability.

Whichever database backend you choose, you should ensure that it respects consistency in one crucial 
aspect: token deletion. If a token is deleted due to a suspected security breach, it should not come 
back to life later due to a glitch in the database. The Jepsen project (https://jepsen.io/analyses) 
provides detailed analysis and testing of the consistency properties of many databases.

### Generating Token ids
The first thing you need to do when issuing a new token is to generate a fresh token ID. 
You shouldn’t use a normal database sequence for this, because token IDs must be **unguessable** for 
an attacker. Otherwise an attacker can simply wait for another user to login and then guess the ID of 
their token to hijack their session. IDs generated by database sequences tend to be extremely predictable, 
often just a simple incrementing integer value. To be secure, a token ID should be generated with a 
high degree of entropy from a cryptographically-secure random number generator (RNG). In Java, this means 
the random data should come from a `SecureRandom` object.
  
> **_DEFINITION_** In information security, entropy is a measure of the randomness or unpredictability of data. 
> It is often used to describe the strength of encryption keys or passwords. The more entropy a variable 
> has, the more difficult it is to guess what value it has. For long-lived values that should be 
> un-guessable by an adversary with access to large amounts of computing power, an entropy of 128 bits 
> is a secure minimum. If your API issues a very large number of tokens with long expiry times, then you 
> should consider a higher entropy of 160 bits or more. For short-lived tokens and an API with rate-limiting
> on token validation requests, you could reduce the entropy to reduce the token size, but this is rarely 
> worth it.
  
#### Trying it out
- create a test user
```sh
curl -i --cacert "$(mkcert -CAROOT)/rootCA.pem" -H 'Content-Type: application/json' -d '{"username":"test","password":"password"}' https://localhost:4567/users
```
- create a token
```sh
curl -i --cacert "$(mkcert -CAROOT)/rootCA.pem" -u test:password -H 'Content-Type: application/json' -X POST https://localhost:4567/sessions
```
Note the lack of a `Set-Cookie` header in the response. There is just the new token in the JSON body. 